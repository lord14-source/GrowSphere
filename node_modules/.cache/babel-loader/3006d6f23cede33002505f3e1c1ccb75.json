{"ast":null,"code":"import React, { createContext, useState, useReducer, useRef, useEffect, useCallback, useMemo, useContext } from 'react';\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n  };\n  return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\nfunction __generator(thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (g && (g = 0, op[0] && (_ = 0)), _) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\nfunction e(e, t) {\n  var i = {};\n  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (i[o] = e[o]);\n  if (null != e && \"function\" == typeof Object.getOwnPropertySymbols) {\n    var n = 0;\n    for (o = Object.getOwnPropertySymbols(e); n < o.length; n++) t.indexOf(o[n]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[n]) && (i[o[n]] = e[o[n]]);\n  }\n  return i;\n}\n\"function\" == typeof SuppressedError && SuppressedError;\nvar t = \"undefined\" != typeof globalThis ? globalThis : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : {};\nfunction i(e) {\n  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, \"default\") ? e.default : e;\n}\nfunction o(e, t) {\n  return e(t = {\n    exports: {}\n  }, t.exports), t.exports;\n}\nvar n = o(function (e, t) {\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n  var i = function () {\n    function e() {\n      var e = this;\n      this.locked = new Map(), this.addToLocked = function (t, i) {\n        var o = e.locked.get(t);\n        void 0 === o ? void 0 === i ? e.locked.set(t, []) : e.locked.set(t, [i]) : void 0 !== i && (o.unshift(i), e.locked.set(t, o));\n      }, this.isLocked = function (t) {\n        return e.locked.has(t);\n      }, this.lock = function (t) {\n        return new Promise(function (i, o) {\n          e.isLocked(t) ? e.addToLocked(t, i) : (e.addToLocked(t), i());\n        });\n      }, this.unlock = function (t) {\n        var i = e.locked.get(t);\n        if (void 0 !== i && 0 !== i.length) {\n          var o = i.pop();\n          e.locked.set(t, i), void 0 !== o && setTimeout(o, 0);\n        } else e.locked.delete(t);\n      };\n    }\n    return e.getInstance = function () {\n      return void 0 === e.instance && (e.instance = new e()), e.instance;\n    }, e;\n  }();\n  t.default = function () {\n    return i.getInstance();\n  };\n});\ni(n);\nvar a = i(o(function (e, i) {\n  var o = t && t.__awaiter || function (e, t, i, o) {\n      return new (i || (i = Promise))(function (n, a) {\n        function r(e) {\n          try {\n            c(o.next(e));\n          } catch (e) {\n            a(e);\n          }\n        }\n        function s(e) {\n          try {\n            c(o.throw(e));\n          } catch (e) {\n            a(e);\n          }\n        }\n        function c(e) {\n          e.done ? n(e.value) : new i(function (t) {\n            t(e.value);\n          }).then(r, s);\n        }\n        c((o = o.apply(e, t || [])).next());\n      });\n    },\n    a = t && t.__generator || function (e, t) {\n      var i,\n        o,\n        n,\n        a,\n        r = {\n          label: 0,\n          sent: function () {\n            if (1 & n[0]) throw n[1];\n            return n[1];\n          },\n          trys: [],\n          ops: []\n        };\n      return a = {\n        next: s(0),\n        throw: s(1),\n        return: s(2)\n      }, \"function\" == typeof Symbol && (a[Symbol.iterator] = function () {\n        return this;\n      }), a;\n      function s(a) {\n        return function (s) {\n          return function (a) {\n            if (i) throw new TypeError(\"Generator is already executing.\");\n            for (; r;) try {\n              if (i = 1, o && (n = 2 & a[0] ? o.return : a[0] ? o.throw || ((n = o.return) && n.call(o), 0) : o.next) && !(n = n.call(o, a[1])).done) return n;\n              switch (o = 0, n && (a = [2 & a[0], n.value]), a[0]) {\n                case 0:\n                case 1:\n                  n = a;\n                  break;\n                case 4:\n                  return r.label++, {\n                    value: a[1],\n                    done: !1\n                  };\n                case 5:\n                  r.label++, o = a[1], a = [0];\n                  continue;\n                case 7:\n                  a = r.ops.pop(), r.trys.pop();\n                  continue;\n                default:\n                  if (!(n = r.trys, (n = n.length > 0 && n[n.length - 1]) || 6 !== a[0] && 2 !== a[0])) {\n                    r = 0;\n                    continue;\n                  }\n                  if (3 === a[0] && (!n || a[1] > n[0] && a[1] < n[3])) {\n                    r.label = a[1];\n                    break;\n                  }\n                  if (6 === a[0] && r.label < n[1]) {\n                    r.label = n[1], n = a;\n                    break;\n                  }\n                  if (n && r.label < n[2]) {\n                    r.label = n[2], r.ops.push(a);\n                    break;\n                  }\n                  n[2] && r.ops.pop(), r.trys.pop();\n                  continue;\n              }\n              a = t.call(e, r);\n            } catch (e) {\n              a = [6, e], o = 0;\n            } finally {\n              i = n = 0;\n            }\n            if (5 & a[0]) throw a[1];\n            return {\n              value: a[0] ? a[1] : void 0,\n              done: !0\n            };\n          }([a, s]);\n        };\n      }\n    },\n    r = t;\n  Object.defineProperty(i, \"__esModule\", {\n    value: !0\n  });\n  var s = \"browser-tabs-lock-key\",\n    c = {\n      key: function (e) {\n        return o(r, void 0, void 0, function () {\n          return a(this, function (e) {\n            throw new Error(\"Unsupported\");\n          });\n        });\n      },\n      getItem: function (e) {\n        return o(r, void 0, void 0, function () {\n          return a(this, function (e) {\n            throw new Error(\"Unsupported\");\n          });\n        });\n      },\n      clear: function () {\n        return o(r, void 0, void 0, function () {\n          return a(this, function (e) {\n            return [2, window.localStorage.clear()];\n          });\n        });\n      },\n      removeItem: function (e) {\n        return o(r, void 0, void 0, function () {\n          return a(this, function (e) {\n            throw new Error(\"Unsupported\");\n          });\n        });\n      },\n      setItem: function (e, t) {\n        return o(r, void 0, void 0, function () {\n          return a(this, function (e) {\n            throw new Error(\"Unsupported\");\n          });\n        });\n      },\n      keySync: function (e) {\n        return window.localStorage.key(e);\n      },\n      getItemSync: function (e) {\n        return window.localStorage.getItem(e);\n      },\n      clearSync: function () {\n        return window.localStorage.clear();\n      },\n      removeItemSync: function (e) {\n        return window.localStorage.removeItem(e);\n      },\n      setItemSync: function (e, t) {\n        return window.localStorage.setItem(e, t);\n      }\n    };\n  function d(e) {\n    return new Promise(function (t) {\n      return setTimeout(t, e);\n    });\n  }\n  function u(e) {\n    for (var t = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz\", i = \"\", o = 0; o < e; o++) {\n      i += t[Math.floor(Math.random() * t.length)];\n    }\n    return i;\n  }\n  var l = function () {\n    function e(t) {\n      this.acquiredIatSet = new Set(), this.storageHandler = void 0, this.id = Date.now().toString() + u(15), this.acquireLock = this.acquireLock.bind(this), this.releaseLock = this.releaseLock.bind(this), this.releaseLock__private__ = this.releaseLock__private__.bind(this), this.waitForSomethingToChange = this.waitForSomethingToChange.bind(this), this.refreshLockWhileAcquired = this.refreshLockWhileAcquired.bind(this), this.storageHandler = t, void 0 === e.waiters && (e.waiters = []);\n    }\n    return e.prototype.acquireLock = function (t, i) {\n      return void 0 === i && (i = 5e3), o(this, void 0, void 0, function () {\n        var o, n, r, l, h, p, m;\n        return a(this, function (a) {\n          switch (a.label) {\n            case 0:\n              o = Date.now() + u(4), n = Date.now() + i, r = s + \"-\" + t, l = void 0 === this.storageHandler ? c : this.storageHandler, a.label = 1;\n            case 1:\n              return Date.now() < n ? [4, d(30)] : [3, 8];\n            case 2:\n              return a.sent(), null !== l.getItemSync(r) ? [3, 5] : (h = this.id + \"-\" + t + \"-\" + o, [4, d(Math.floor(25 * Math.random()))]);\n            case 3:\n              return a.sent(), l.setItemSync(r, JSON.stringify({\n                id: this.id,\n                iat: o,\n                timeoutKey: h,\n                timeAcquired: Date.now(),\n                timeRefreshed: Date.now()\n              })), [4, d(30)];\n            case 4:\n              return a.sent(), null !== (p = l.getItemSync(r)) && (m = JSON.parse(p)).id === this.id && m.iat === o ? (this.acquiredIatSet.add(o), this.refreshLockWhileAcquired(r, o), [2, !0]) : [3, 7];\n            case 5:\n              return e.lockCorrector(void 0 === this.storageHandler ? c : this.storageHandler), [4, this.waitForSomethingToChange(n)];\n            case 6:\n              a.sent(), a.label = 7;\n            case 7:\n              return o = Date.now() + u(4), [3, 1];\n            case 8:\n              return [2, !1];\n          }\n        });\n      });\n    }, e.prototype.refreshLockWhileAcquired = function (e, t) {\n      return o(this, void 0, void 0, function () {\n        var i = this;\n        return a(this, function (r) {\n          return setTimeout(function () {\n            return o(i, void 0, void 0, function () {\n              var i, o, r;\n              return a(this, function (a) {\n                switch (a.label) {\n                  case 0:\n                    return [4, n.default().lock(t)];\n                  case 1:\n                    return a.sent(), this.acquiredIatSet.has(t) ? (i = void 0 === this.storageHandler ? c : this.storageHandler, null === (o = i.getItemSync(e)) ? (n.default().unlock(t), [2]) : ((r = JSON.parse(o)).timeRefreshed = Date.now(), i.setItemSync(e, JSON.stringify(r)), n.default().unlock(t), this.refreshLockWhileAcquired(e, t), [2])) : (n.default().unlock(t), [2]);\n                }\n              });\n            });\n          }, 1e3), [2];\n        });\n      });\n    }, e.prototype.waitForSomethingToChange = function (t) {\n      return o(this, void 0, void 0, function () {\n        return a(this, function (i) {\n          switch (i.label) {\n            case 0:\n              return [4, new Promise(function (i) {\n                var o = !1,\n                  n = Date.now(),\n                  a = !1;\n                function r() {\n                  if (a || (window.removeEventListener(\"storage\", r), e.removeFromWaiting(r), clearTimeout(s), a = !0), !o) {\n                    o = !0;\n                    var t = 50 - (Date.now() - n);\n                    t > 0 ? setTimeout(i, t) : i(null);\n                  }\n                }\n                window.addEventListener(\"storage\", r), e.addToWaiting(r);\n                var s = setTimeout(r, Math.max(0, t - Date.now()));\n              })];\n            case 1:\n              return i.sent(), [2];\n          }\n        });\n      });\n    }, e.addToWaiting = function (t) {\n      this.removeFromWaiting(t), void 0 !== e.waiters && e.waiters.push(t);\n    }, e.removeFromWaiting = function (t) {\n      void 0 !== e.waiters && (e.waiters = e.waiters.filter(function (e) {\n        return e !== t;\n      }));\n    }, e.notifyWaiters = function () {\n      void 0 !== e.waiters && e.waiters.slice().forEach(function (e) {\n        return e();\n      });\n    }, e.prototype.releaseLock = function (e) {\n      return o(this, void 0, void 0, function () {\n        return a(this, function (t) {\n          switch (t.label) {\n            case 0:\n              return [4, this.releaseLock__private__(e)];\n            case 1:\n              return [2, t.sent()];\n          }\n        });\n      });\n    }, e.prototype.releaseLock__private__ = function (t) {\n      return o(this, void 0, void 0, function () {\n        var i, o, r, d;\n        return a(this, function (a) {\n          switch (a.label) {\n            case 0:\n              return i = void 0 === this.storageHandler ? c : this.storageHandler, o = s + \"-\" + t, null === (r = i.getItemSync(o)) ? [2] : (d = JSON.parse(r)).id !== this.id ? [3, 2] : [4, n.default().lock(d.iat)];\n            case 1:\n              a.sent(), this.acquiredIatSet.delete(d.iat), i.removeItemSync(o), n.default().unlock(d.iat), e.notifyWaiters(), a.label = 2;\n            case 2:\n              return [2];\n          }\n        });\n      });\n    }, e.lockCorrector = function (t) {\n      for (var i = Date.now() - 5e3, o = t, n = [], a = 0;;) {\n        var r = o.keySync(a);\n        if (null === r) break;\n        n.push(r), a++;\n      }\n      for (var c = !1, d = 0; d < n.length; d++) {\n        var u = n[d];\n        if (u.includes(s)) {\n          var l = o.getItemSync(u);\n          if (null !== l) {\n            var h = JSON.parse(l);\n            (void 0 === h.timeRefreshed && h.timeAcquired < i || void 0 !== h.timeRefreshed && h.timeRefreshed < i) && (o.removeItemSync(u), c = !0);\n          }\n        }\n      }\n      c && e.notifyWaiters();\n    }, e.waiters = void 0, e;\n  }();\n  i.default = l;\n}));\nconst r = {\n    timeoutInSeconds: 60\n  },\n  s = {\n    name: \"auth0-spa-js\",\n    version: \"2.1.3\"\n  },\n  c = () => Date.now();\nclass d extends Error {\n  constructor(e, t) {\n    super(t), this.error = e, this.error_description = t, Object.setPrototypeOf(this, d.prototype);\n  }\n  static fromPayload({\n    error: e,\n    error_description: t\n  }) {\n    return new d(e, t);\n  }\n}\nclass u extends d {\n  constructor(e, t, i, o = null) {\n    super(e, t), this.state = i, this.appState = o, Object.setPrototypeOf(this, u.prototype);\n  }\n}\nclass l extends d {\n  constructor() {\n    super(\"timeout\", \"Timeout\"), Object.setPrototypeOf(this, l.prototype);\n  }\n}\nclass h extends l {\n  constructor(e) {\n    super(), this.popup = e, Object.setPrototypeOf(this, h.prototype);\n  }\n}\nclass p extends d {\n  constructor(e) {\n    super(\"cancelled\", \"Popup closed\"), this.popup = e, Object.setPrototypeOf(this, p.prototype);\n  }\n}\nclass m extends d {\n  constructor(e, t, i) {\n    super(e, t), this.mfa_token = i, Object.setPrototypeOf(this, m.prototype);\n  }\n}\nclass f extends d {\n  constructor(e, t) {\n    super(\"missing_refresh_token\", `Missing Refresh Token (audience: '${g(e, [\"default\"])}', scope: '${g(t)}')`), this.audience = e, this.scope = t, Object.setPrototypeOf(this, f.prototype);\n  }\n}\nfunction g(e, t = []) {\n  return e && !t.includes(e) ? e : \"\";\n}\nconst w = () => window.crypto,\n  y = () => {\n    const e = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_~.\";\n    let t = \"\";\n    return Array.from(w().getRandomValues(new Uint8Array(43))).forEach(i => t += e[i % e.length]), t;\n  },\n  k = e => btoa(e),\n  v = t => {\n    var {\n        clientId: i\n      } = t,\n      o = e(t, [\"clientId\"]);\n    return new URLSearchParams((e => Object.keys(e).filter(t => void 0 !== e[t]).reduce((t, i) => Object.assign(Object.assign({}, t), {\n      [i]: e[i]\n    }), {}))(Object.assign({\n      client_id: i\n    }, o))).toString();\n  },\n  b = e => (e => decodeURIComponent(atob(e).split(\"\").map(e => \"%\" + (\"00\" + e.charCodeAt(0).toString(16)).slice(-2)).join(\"\")))(e.replace(/_/g, \"/\").replace(/-/g, \"+\")),\n  _ = async (e, t) => {\n    const i = await fetch(e, t);\n    return {\n      ok: i.ok,\n      json: await i.json()\n    };\n  },\n  I = async (e, t, i) => {\n    const o = new AbortController();\n    let n;\n    return t.signal = o.signal, Promise.race([_(e, t), new Promise((e, t) => {\n      n = setTimeout(() => {\n        o.abort(), t(new Error(\"Timeout when executing 'fetch'\"));\n      }, i);\n    })]).finally(() => {\n      clearTimeout(n);\n    });\n  },\n  S = async (e, t, i, o, n, a, r) => {\n    return s = {\n      auth: {\n        audience: t,\n        scope: i\n      },\n      timeout: n,\n      fetchUrl: e,\n      fetchOptions: o,\n      useFormData: r\n    }, c = a, new Promise(function (e, t) {\n      const i = new MessageChannel();\n      i.port1.onmessage = function (o) {\n        o.data.error ? t(new Error(o.data.error)) : e(o.data), i.port1.close();\n      }, c.postMessage(s, [i.port2]);\n    });\n    var s, c;\n  },\n  O = async (e, t, i, o, n, a, r = 1e4) => n ? S(e, t, i, o, r, n, a) : I(e, o, r);\nasync function T(t, i) {\n  var {\n      baseUrl: o,\n      timeout: n,\n      audience: a,\n      scope: r,\n      auth0Client: c,\n      useFormData: u\n    } = t,\n    l = e(t, [\"baseUrl\", \"timeout\", \"audience\", \"scope\", \"auth0Client\", \"useFormData\"]);\n  const h = u ? v(l) : JSON.stringify(l);\n  return await async function (t, i, o, n, a, r, s) {\n    let c,\n      u = null;\n    for (let e = 0; e < 3; e++) try {\n      c = await O(t, o, n, a, r, s, i), u = null;\n      break;\n    } catch (e) {\n      u = e;\n    }\n    if (u) throw u;\n    const l = c.json,\n      {\n        error: h,\n        error_description: p\n      } = l,\n      g = e(l, [\"error\", \"error_description\"]),\n      {\n        ok: w\n      } = c;\n    if (!w) {\n      const e = p || `HTTP error. Unable to fetch ${t}`;\n      if (\"mfa_required\" === h) throw new m(h, e, g.mfa_token);\n      if (\"missing_refresh_token\" === h) throw new f(o, n);\n      throw new d(h || \"request_error\", e);\n    }\n    return g;\n  }(`${o}/oauth/token`, n, a || \"default\", r, {\n    method: \"POST\",\n    body: h,\n    headers: {\n      \"Content-Type\": u ? \"application/x-www-form-urlencoded\" : \"application/json\",\n      \"Auth0-Client\": btoa(JSON.stringify(c || s))\n    }\n  }, i, u);\n}\nconst j = (...e) => {\n  return (t = e.filter(Boolean).join(\" \").trim().split(/\\s+/), Array.from(new Set(t))).join(\" \");\n  var t;\n};\nclass C {\n  constructor(e, t = \"@@auth0spajs@@\", i) {\n    this.prefix = t, this.suffix = i, this.clientId = e.clientId, this.scope = e.scope, this.audience = e.audience;\n  }\n  toKey() {\n    return [this.prefix, this.clientId, this.audience, this.scope, this.suffix].filter(Boolean).join(\"::\");\n  }\n  static fromKey(e) {\n    const [t, i, o, n] = e.split(\"::\");\n    return new C({\n      clientId: i,\n      scope: n,\n      audience: o\n    }, t);\n  }\n  static fromCacheEntry(e) {\n    const {\n      scope: t,\n      audience: i,\n      client_id: o\n    } = e;\n    return new C({\n      scope: t,\n      audience: i,\n      clientId: o\n    });\n  }\n}\nclass z {\n  set(e, t) {\n    localStorage.setItem(e, JSON.stringify(t));\n  }\n  get(e) {\n    const t = window.localStorage.getItem(e);\n    if (t) try {\n      return JSON.parse(t);\n    } catch (e) {\n      return;\n    }\n  }\n  remove(e) {\n    localStorage.removeItem(e);\n  }\n  allKeys() {\n    return Object.keys(window.localStorage).filter(e => e.startsWith(\"@@auth0spajs@@\"));\n  }\n}\nclass P {\n  constructor() {\n    this.enclosedCache = function () {\n      let e = {};\n      return {\n        set(t, i) {\n          e[t] = i;\n        },\n        get(t) {\n          const i = e[t];\n          if (i) return i;\n        },\n        remove(t) {\n          delete e[t];\n        },\n        allKeys: () => Object.keys(e)\n      };\n    }();\n  }\n}\nclass x {\n  constructor(e, t, i) {\n    this.cache = e, this.keyManifest = t, this.nowProvider = i || c;\n  }\n  async setIdToken(e, t, i) {\n    var o;\n    const n = this.getIdTokenCacheKey(e);\n    await this.cache.set(n, {\n      id_token: t,\n      decodedToken: i\n    }), await (null === (o = this.keyManifest) || void 0 === o ? void 0 : o.add(n));\n  }\n  async getIdToken(e) {\n    const t = await this.cache.get(this.getIdTokenCacheKey(e.clientId));\n    if (!t && e.scope && e.audience) {\n      const t = await this.get(e);\n      if (!t) return;\n      if (!t.id_token || !t.decodedToken) return;\n      return {\n        id_token: t.id_token,\n        decodedToken: t.decodedToken\n      };\n    }\n    if (t) return {\n      id_token: t.id_token,\n      decodedToken: t.decodedToken\n    };\n  }\n  async get(e, t = 0) {\n    var i;\n    let o = await this.cache.get(e.toKey());\n    if (!o) {\n      const t = await this.getCacheKeys();\n      if (!t) return;\n      const i = this.matchExistingCacheKey(e, t);\n      i && (o = await this.cache.get(i));\n    }\n    if (!o) return;\n    const n = await this.nowProvider(),\n      a = Math.floor(n / 1e3);\n    return o.expiresAt - t < a ? o.body.refresh_token ? (o.body = {\n      refresh_token: o.body.refresh_token\n    }, await this.cache.set(e.toKey(), o), o.body) : (await this.cache.remove(e.toKey()), void (await (null === (i = this.keyManifest) || void 0 === i ? void 0 : i.remove(e.toKey())))) : o.body;\n  }\n  async set(e) {\n    var t;\n    const i = new C({\n        clientId: e.client_id,\n        scope: e.scope,\n        audience: e.audience\n      }),\n      o = await this.wrapCacheEntry(e);\n    await this.cache.set(i.toKey(), o), await (null === (t = this.keyManifest) || void 0 === t ? void 0 : t.add(i.toKey()));\n  }\n  async clear(e) {\n    var t;\n    const i = await this.getCacheKeys();\n    i && (await i.filter(t => !e || t.includes(e)).reduce(async (e, t) => {\n      await e, await this.cache.remove(t);\n    }, Promise.resolve()), await (null === (t = this.keyManifest) || void 0 === t ? void 0 : t.clear()));\n  }\n  async wrapCacheEntry(e) {\n    const t = await this.nowProvider();\n    return {\n      body: e,\n      expiresAt: Math.floor(t / 1e3) + e.expires_in\n    };\n  }\n  async getCacheKeys() {\n    var e;\n    return this.keyManifest ? null === (e = await this.keyManifest.get()) || void 0 === e ? void 0 : e.keys : this.cache.allKeys ? this.cache.allKeys() : void 0;\n  }\n  getIdTokenCacheKey(e) {\n    return new C({\n      clientId: e\n    }, \"@@auth0spajs@@\", \"@@user@@\").toKey();\n  }\n  matchExistingCacheKey(e, t) {\n    return t.filter(t => {\n      var i;\n      const o = C.fromKey(t),\n        n = new Set(o.scope && o.scope.split(\" \")),\n        a = (null === (i = e.scope) || void 0 === i ? void 0 : i.split(\" \")) || [],\n        r = o.scope && a.reduce((e, t) => e && n.has(t), !0);\n      return \"@@auth0spajs@@\" === o.prefix && o.clientId === e.clientId && o.audience === e.audience && r;\n    })[0];\n  }\n}\nclass Z {\n  constructor(e, t, i) {\n    this.storage = e, this.clientId = t, this.cookieDomain = i, this.storageKey = `a0.spajs.txs.${this.clientId}`;\n  }\n  create(e) {\n    this.storage.save(this.storageKey, e, {\n      daysUntilExpire: 1,\n      cookieDomain: this.cookieDomain\n    });\n  }\n  get() {\n    return this.storage.get(this.storageKey);\n  }\n  remove() {\n    this.storage.remove(this.storageKey, {\n      cookieDomain: this.cookieDomain\n    });\n  }\n}\nconst K = e => \"number\" == typeof e,\n  W = [\"iss\", \"aud\", \"exp\", \"nbf\", \"iat\", \"jti\", \"azp\", \"nonce\", \"auth_time\", \"at_hash\", \"c_hash\", \"acr\", \"amr\", \"sub_jwk\", \"cnf\", \"sip_from_tag\", \"sip_date\", \"sip_callid\", \"sip_cseq_num\", \"sip_via_branch\", \"orig\", \"dest\", \"mky\", \"events\", \"toe\", \"txn\", \"rph\", \"sid\", \"vot\", \"vtm\"],\n  E = e => {\n    if (!e.id_token) throw new Error(\"ID token is required but missing\");\n    const t = (e => {\n      const t = e.split(\".\"),\n        [i, o, n] = t;\n      if (3 !== t.length || !i || !o || !n) throw new Error(\"ID token could not be decoded\");\n      const a = JSON.parse(b(o)),\n        r = {\n          __raw: e\n        },\n        s = {};\n      return Object.keys(a).forEach(e => {\n        r[e] = a[e], W.includes(e) || (s[e] = a[e]);\n      }), {\n        encoded: {\n          header: i,\n          payload: o,\n          signature: n\n        },\n        header: JSON.parse(b(i)),\n        claims: r,\n        user: s\n      };\n    })(e.id_token);\n    if (!t.claims.iss) throw new Error(\"Issuer (iss) claim must be a string present in the ID token\");\n    if (t.claims.iss !== e.iss) throw new Error(`Issuer (iss) claim mismatch in the ID token; expected \"${e.iss}\", found \"${t.claims.iss}\"`);\n    if (!t.user.sub) throw new Error(\"Subject (sub) claim must be a string present in the ID token\");\n    if (\"RS256\" !== t.header.alg) throw new Error(`Signature algorithm of \"${t.header.alg}\" is not supported. Expected the ID token to be signed with \"RS256\".`);\n    if (!t.claims.aud || \"string\" != typeof t.claims.aud && !Array.isArray(t.claims.aud)) throw new Error(\"Audience (aud) claim must be a string or array of strings present in the ID token\");\n    if (Array.isArray(t.claims.aud)) {\n      if (!t.claims.aud.includes(e.aud)) throw new Error(`Audience (aud) claim mismatch in the ID token; expected \"${e.aud}\" but was not one of \"${t.claims.aud.join(\", \")}\"`);\n      if (t.claims.aud.length > 1) {\n        if (!t.claims.azp) throw new Error(\"Authorized Party (azp) claim must be a string present in the ID token when Audience (aud) claim has multiple values\");\n        if (t.claims.azp !== e.aud) throw new Error(`Authorized Party (azp) claim mismatch in the ID token; expected \"${e.aud}\", found \"${t.claims.azp}\"`);\n      }\n    } else if (t.claims.aud !== e.aud) throw new Error(`Audience (aud) claim mismatch in the ID token; expected \"${e.aud}\" but found \"${t.claims.aud}\"`);\n    if (e.nonce) {\n      if (!t.claims.nonce) throw new Error(\"Nonce (nonce) claim must be a string present in the ID token\");\n      if (t.claims.nonce !== e.nonce) throw new Error(`Nonce (nonce) claim mismatch in the ID token; expected \"${e.nonce}\", found \"${t.claims.nonce}\"`);\n    }\n    if (e.max_age && !K(t.claims.auth_time)) throw new Error(\"Authentication Time (auth_time) claim must be a number present in the ID token when Max Age (max_age) is specified\");\n    if (null == t.claims.exp || !K(t.claims.exp)) throw new Error(\"Expiration Time (exp) claim must be a number present in the ID token\");\n    if (!K(t.claims.iat)) throw new Error(\"Issued At (iat) claim must be a number present in the ID token\");\n    const i = e.leeway || 60,\n      o = new Date(e.now || Date.now()),\n      n = new Date(0);\n    if (n.setUTCSeconds(t.claims.exp + i), o > n) throw new Error(`Expiration Time (exp) claim error in the ID token; current time (${o}) is after expiration time (${n})`);\n    if (null != t.claims.nbf && K(t.claims.nbf)) {\n      const e = new Date(0);\n      if (e.setUTCSeconds(t.claims.nbf - i), o < e) throw new Error(`Not Before time (nbf) claim in the ID token indicates that this token can't be used just yet. Current time (${o}) is before ${e}`);\n    }\n    if (null != t.claims.auth_time && K(t.claims.auth_time)) {\n      const n = new Date(0);\n      if (n.setUTCSeconds(parseInt(t.claims.auth_time) + e.max_age + i), o > n) throw new Error(`Authentication Time (auth_time) claim in the ID token indicates that too much time has passed since the last end-user authentication. Current time (${o}) is after last auth at ${n}`);\n    }\n    if (e.organization) {\n      const i = e.organization.trim();\n      if (i.startsWith(\"org_\")) {\n        const e = i;\n        if (!t.claims.org_id) throw new Error(\"Organization ID (org_id) claim must be a string present in the ID token\");\n        if (e !== t.claims.org_id) throw new Error(`Organization ID (org_id) claim mismatch in the ID token; expected \"${e}\", found \"${t.claims.org_id}\"`);\n      } else {\n        const e = i.toLowerCase();\n        if (!t.claims.org_name) throw new Error(\"Organization Name (org_name) claim must be a string present in the ID token\");\n        if (e !== t.claims.org_name) throw new Error(`Organization Name (org_name) claim mismatch in the ID token; expected \"${e}\", found \"${t.claims.org_name}\"`);\n      }\n    }\n    return t;\n  };\nvar R = o(function (e, i) {\n  var o = t && t.__assign || function () {\n    return o = Object.assign || function (e) {\n      for (var t, i = 1, o = arguments.length; i < o; i++) for (var n in t = arguments[i]) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);\n      return e;\n    }, o.apply(this, arguments);\n  };\n  function n(e, t) {\n    if (!t) return \"\";\n    var i = \"; \" + e;\n    return !0 === t ? i : i + \"=\" + t;\n  }\n  function a(e, t, i) {\n    return encodeURIComponent(e).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/\\(/g, \"%28\").replace(/\\)/g, \"%29\") + \"=\" + encodeURIComponent(t).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent) + function (e) {\n      if (\"number\" == typeof e.expires) {\n        var t = new Date();\n        t.setMilliseconds(t.getMilliseconds() + 864e5 * e.expires), e.expires = t;\n      }\n      return n(\"Expires\", e.expires ? e.expires.toUTCString() : \"\") + n(\"Domain\", e.domain) + n(\"Path\", e.path) + n(\"Secure\", e.secure) + n(\"SameSite\", e.sameSite);\n    }(i);\n  }\n  function r(e) {\n    for (var t = {}, i = e ? e.split(\"; \") : [], o = /(%[\\dA-F]{2})+/gi, n = 0; n < i.length; n++) {\n      var a = i[n].split(\"=\"),\n        r = a.slice(1).join(\"=\");\n      '\"' === r.charAt(0) && (r = r.slice(1, -1));\n      try {\n        t[a[0].replace(o, decodeURIComponent)] = r.replace(o, decodeURIComponent);\n      } catch (e) {}\n    }\n    return t;\n  }\n  function s() {\n    return r(document.cookie);\n  }\n  function c(e, t, i) {\n    document.cookie = a(e, t, o({\n      path: \"/\"\n    }, i));\n  }\n  i.__esModule = !0, i.encode = a, i.parse = r, i.getAll = s, i.get = function (e) {\n    return s()[e];\n  }, i.set = c, i.remove = function (e, t) {\n    c(e, \"\", o(o({}, t), {\n      expires: -1\n    }));\n  };\n});\ni(R), R.encode, R.parse, R.getAll;\nvar U = R.get,\n  L = R.set,\n  D = R.remove;\nconst X = {\n    get(e) {\n      const t = U(e);\n      if (void 0 !== t) return JSON.parse(t);\n    },\n    save(e, t, i) {\n      let o = {};\n      \"https:\" === window.location.protocol && (o = {\n        secure: !0,\n        sameSite: \"none\"\n      }), (null == i ? void 0 : i.daysUntilExpire) && (o.expires = i.daysUntilExpire), (null == i ? void 0 : i.cookieDomain) && (o.domain = i.cookieDomain), L(e, JSON.stringify(t), o);\n    },\n    remove(e, t) {\n      let i = {};\n      (null == t ? void 0 : t.cookieDomain) && (i.domain = t.cookieDomain), D(e, i);\n    }\n  },\n  N = {\n    get(e) {\n      const t = X.get(e);\n      return t || X.get(`_legacy_${e}`);\n    },\n    save(e, t, i) {\n      let o = {};\n      \"https:\" === window.location.protocol && (o = {\n        secure: !0\n      }), (null == i ? void 0 : i.daysUntilExpire) && (o.expires = i.daysUntilExpire), (null == i ? void 0 : i.cookieDomain) && (o.domain = i.cookieDomain), L(`_legacy_${e}`, JSON.stringify(t), o), X.save(e, t, i);\n    },\n    remove(e, t) {\n      let i = {};\n      (null == t ? void 0 : t.cookieDomain) && (i.domain = t.cookieDomain), D(e, i), X.remove(e, t), X.remove(`_legacy_${e}`, t);\n    }\n  },\n  J = {\n    get(e) {\n      if (\"undefined\" == typeof sessionStorage) return;\n      const t = sessionStorage.getItem(e);\n      return null != t ? JSON.parse(t) : void 0;\n    },\n    save(e, t) {\n      sessionStorage.setItem(e, JSON.stringify(t));\n    },\n    remove(e) {\n      sessionStorage.removeItem(e);\n    }\n  };\nfunction F(e, t, i) {\n  var o = void 0 === t ? null : t,\n    n = function (e, t) {\n      var i = atob(e);\n      if (t) {\n        for (var o = new Uint8Array(i.length), n = 0, a = i.length; n < a; ++n) o[n] = i.charCodeAt(n);\n        return String.fromCharCode.apply(null, new Uint16Array(o.buffer));\n      }\n      return i;\n    }(e, void 0 !== i && i),\n    a = n.indexOf(\"\\n\", 10) + 1,\n    r = n.substring(a) + (o ? \"//# sourceMappingURL=\" + o : \"\"),\n    s = new Blob([r], {\n      type: \"application/javascript\"\n    });\n  return URL.createObjectURL(s);\n}\nvar H,\n  Y,\n  G,\n  V,\n  M = (H = \"Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwohZnVuY3Rpb24oKXsidXNlIHN0cmljdCI7Y2xhc3MgZSBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKHQscil7c3VwZXIociksdGhpcy5lcnJvcj10LHRoaXMuZXJyb3JfZGVzY3JpcHRpb249cixPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcyxlLnByb3RvdHlwZSl9c3RhdGljIGZyb21QYXlsb2FkKHtlcnJvcjp0LGVycm9yX2Rlc2NyaXB0aW9uOnJ9KXtyZXR1cm4gbmV3IGUodCxyKX19Y2xhc3MgdCBleHRlbmRzIGV7Y29uc3RydWN0b3IoZSxzKXtzdXBlcigibWlzc2luZ19yZWZyZXNoX3Rva2VuIixgTWlzc2luZyBSZWZyZXNoIFRva2VuIChhdWRpZW5jZTogJyR7cihlLFsiZGVmYXVsdCJdKX0nLCBzY29wZTogJyR7cihzKX0nKWApLHRoaXMuYXVkaWVuY2U9ZSx0aGlzLnNjb3BlPXMsT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsdC5wcm90b3R5cGUpfX1mdW5jdGlvbiByKGUsdD1bXSl7cmV0dXJuIGUmJiF0LmluY2x1ZGVzKGUpP2U6IiJ9ImZ1bmN0aW9uIj09dHlwZW9mIFN1cHByZXNzZWRFcnJvciYmU3VwcHJlc3NlZEVycm9yO2NvbnN0IHM9ZT0+e3ZhcntjbGllbnRJZDp0fT1lLHI9ZnVuY3Rpb24oZSx0KXt2YXIgcj17fTtmb3IodmFyIHMgaW4gZSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxzKSYmdC5pbmRleE9mKHMpPDAmJihyW3NdPWVbc10pO2lmKG51bGwhPWUmJiJmdW5jdGlvbiI9PXR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgbz0wO2ZvcihzPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7bzxzLmxlbmd0aDtvKyspdC5pbmRleE9mKHNbb10pPDAmJk9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlLHNbb10pJiYocltzW29dXT1lW3Nbb11dKX1yZXR1cm4gcn0oZSxbImNsaWVudElkIl0pO3JldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKChlPT5PYmplY3Qua2V5cyhlKS5maWx0ZXIoKHQ9PnZvaWQgMCE9PWVbdF0pKS5yZWR1Y2UoKCh0LHIpPT5PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse1tyXTplW3JdfSkpLHt9KSkoT2JqZWN0LmFzc2lnbih7Y2xpZW50X2lkOnR9LHIpKSkudG9TdHJpbmcoKX07bGV0IG89e307Y29uc3Qgbj0oZSx0KT0+YCR7ZX18JHt0fWA7YWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsKGFzeW5jKHtkYXRhOnt0aW1lb3V0OmUsYXV0aDpyLGZldGNoVXJsOmksZmV0Y2hPcHRpb25zOmMsdXNlRm9ybURhdGE6YX0scG9ydHM6W3BdfSk9PntsZXQgZjtjb25zdHthdWRpZW5jZTp1LHNjb3BlOmx9PXJ8fHt9O3RyeXtjb25zdCByPWE/KGU9Pntjb25zdCB0PW5ldyBVUkxTZWFyY2hQYXJhbXMoZSkscj17fTtyZXR1cm4gdC5mb3JFYWNoKCgoZSx0KT0+e3JbdF09ZX0pKSxyfSkoYy5ib2R5KTpKU09OLnBhcnNlKGMuYm9keSk7aWYoIXIucmVmcmVzaF90b2tlbiYmInJlZnJlc2hfdG9rZW4iPT09ci5ncmFudF90eXBlKXtjb25zdCBlPSgoZSx0KT0+b1tuKGUsdCldKSh1LGwpO2lmKCFlKXRocm93IG5ldyB0KHUsbCk7Yy5ib2R5PWE/cyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse3JlZnJlc2hfdG9rZW46ZX0pKTpKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse3JlZnJlc2hfdG9rZW46ZX0pKX1sZXQgaCxnOyJmdW5jdGlvbiI9PXR5cGVvZiBBYm9ydENvbnRyb2xsZXImJihoPW5ldyBBYm9ydENvbnRyb2xsZXIsYy5zaWduYWw9aC5zaWduYWwpO3RyeXtnPWF3YWl0IFByb21pc2UucmFjZShbKGQ9ZSxuZXcgUHJvbWlzZSgoZT0+c2V0VGltZW91dChlLGQpKSkpLGZldGNoKGksT2JqZWN0LmFzc2lnbih7fSxjKSldKX1jYXRjaChlKXtyZXR1cm4gdm9pZCBwLnBvc3RNZXNzYWdlKHtlcnJvcjplLm1lc3NhZ2V9KX1pZighZylyZXR1cm4gaCYmaC5hYm9ydCgpLHZvaWQgcC5wb3N0TWVzc2FnZSh7ZXJyb3I6IlRpbWVvdXQgd2hlbiBleGVjdXRpbmcgJ2ZldGNoJyJ9KTtmPWF3YWl0IGcuanNvbigpLGYucmVmcmVzaF90b2tlbj8oKChlLHQscik9PntvW24odCxyKV09ZX0pKGYucmVmcmVzaF90b2tlbix1LGwpLGRlbGV0ZSBmLnJlZnJlc2hfdG9rZW4pOigoZSx0KT0+e2RlbGV0ZSBvW24oZSx0KV19KSh1LGwpLHAucG9zdE1lc3NhZ2Uoe29rOmcub2ssanNvbjpmfSl9Y2F0Y2goZSl7cC5wb3N0TWVzc2FnZSh7b2s6ITEsanNvbjp7ZXJyb3I6ZS5lcnJvcixlcnJvcl9kZXNjcmlwdGlvbjplLm1lc3NhZ2V9fSl9dmFyIGR9KSl9KCk7Cgo=\", Y = null, G = !1, function (e) {\n    return V = V || F(H, Y, G), new Worker(V, e);\n  });\nconst A = {};\nclass B {\n  constructor(e, t) {\n    this.cache = e, this.clientId = t, this.manifestKey = this.createManifestKeyFrom(this.clientId);\n  }\n  async add(e) {\n    var t;\n    const i = new Set((null === (t = await this.cache.get(this.manifestKey)) || void 0 === t ? void 0 : t.keys) || []);\n    i.add(e), await this.cache.set(this.manifestKey, {\n      keys: [...i]\n    });\n  }\n  async remove(e) {\n    const t = await this.cache.get(this.manifestKey);\n    if (t) {\n      const i = new Set(t.keys);\n      return i.delete(e), i.size > 0 ? await this.cache.set(this.manifestKey, {\n        keys: [...i]\n      }) : await this.cache.remove(this.manifestKey);\n    }\n  }\n  get() {\n    return this.cache.get(this.manifestKey);\n  }\n  clear() {\n    return this.cache.remove(this.manifestKey);\n  }\n  createManifestKeyFrom(e) {\n    return `@@auth0spajs@@::${e}`;\n  }\n}\nconst $ = {\n    memory: () => new P().enclosedCache,\n    localstorage: () => new z()\n  },\n  q = e => $[e],\n  Q = t => {\n    const {\n        openUrl: i,\n        onRedirect: o\n      } = t,\n      n = e(t, [\"openUrl\", \"onRedirect\"]);\n    return Object.assign(Object.assign({}, n), {\n      openUrl: !1 === i || i ? i : o\n    });\n  },\n  ee = new a();\nclass te {\n  constructor(e) {\n    let t, i;\n    if (this.userCache = new P().enclosedCache, this.defaultOptions = {\n      authorizationParams: {\n        scope: \"openid profile email\"\n      },\n      useRefreshTokensFallback: !1,\n      useFormData: !0\n    }, this._releaseLockOnPageHide = async () => {\n      await ee.releaseLock(\"auth0.lock.getTokenSilently\"), window.removeEventListener(\"pagehide\", this._releaseLockOnPageHide);\n    }, this.options = Object.assign(Object.assign(Object.assign({}, this.defaultOptions), e), {\n      authorizationParams: Object.assign(Object.assign({}, this.defaultOptions.authorizationParams), e.authorizationParams)\n    }), \"undefined\" != typeof window && (() => {\n      if (!w()) throw new Error(\"For security reasons, `window.crypto` is required to run `auth0-spa-js`.\");\n      if (void 0 === w().subtle) throw new Error(\"\\n      auth0-spa-js must run on a secure origin. See https://github.com/auth0/auth0-spa-js/blob/main/FAQ.md#why-do-i-get-auth0-spa-js-must-run-on-a-secure-origin for more information.\\n    \");\n    })(), e.cache && e.cacheLocation && console.warn(\"Both `cache` and `cacheLocation` options have been specified in the Auth0Client configuration; ignoring `cacheLocation` and using `cache`.\"), e.cache) i = e.cache;else {\n      if (t = e.cacheLocation || \"memory\", !q(t)) throw new Error(`Invalid cache location \"${t}\"`);\n      i = q(t)();\n    }\n    this.httpTimeoutMs = e.httpTimeoutInSeconds ? 1e3 * e.httpTimeoutInSeconds : 1e4, this.cookieStorage = !1 === e.legacySameSiteCookie ? X : N, this.orgHintCookieName = `auth0.${this.options.clientId}.organization_hint`, this.isAuthenticatedCookieName = (e => `auth0.${e}.is.authenticated`)(this.options.clientId), this.sessionCheckExpiryDays = e.sessionCheckExpiryDays || 1;\n    const o = e.useCookiesForTransactions ? this.cookieStorage : J;\n    var n;\n    this.scope = j(\"openid\", this.options.authorizationParams.scope, this.options.useRefreshTokens ? \"offline_access\" : \"\"), this.transactionManager = new Z(o, this.options.clientId, this.options.cookieDomain), this.nowProvider = this.options.nowProvider || c, this.cacheManager = new x(i, i.allKeys ? void 0 : new B(i, this.options.clientId), this.nowProvider), this.domainUrl = (n = this.options.domain, /^https?:\\/\\//.test(n) ? n : `https://${n}`), this.tokenIssuer = ((e, t) => e ? e.startsWith(\"https://\") ? e : `https://${e}/` : `${t}/`)(this.options.issuer, this.domainUrl), \"undefined\" != typeof window && window.Worker && this.options.useRefreshTokens && \"memory\" === t && (this.options.workerUrl ? this.worker = new Worker(this.options.workerUrl) : this.worker = new M());\n  }\n  _url(e) {\n    const t = encodeURIComponent(btoa(JSON.stringify(this.options.auth0Client || s)));\n    return `${this.domainUrl}${e}&auth0Client=${t}`;\n  }\n  _authorizeUrl(e) {\n    return this._url(`/authorize?${v(e)}`);\n  }\n  async _verifyIdToken(e, t, i) {\n    const o = await this.nowProvider();\n    return E({\n      iss: this.tokenIssuer,\n      aud: this.options.clientId,\n      id_token: e,\n      nonce: t,\n      organization: i,\n      leeway: this.options.leeway,\n      max_age: (n = this.options.authorizationParams.max_age, \"string\" != typeof n ? n : parseInt(n, 10) || void 0),\n      now: o\n    });\n    var n;\n  }\n  _processOrgHint(e) {\n    e ? this.cookieStorage.save(this.orgHintCookieName, e, {\n      daysUntilExpire: this.sessionCheckExpiryDays,\n      cookieDomain: this.options.cookieDomain\n    }) : this.cookieStorage.remove(this.orgHintCookieName, {\n      cookieDomain: this.options.cookieDomain\n    });\n  }\n  async _prepareAuthorizeUrl(e, t, i) {\n    const o = k(y()),\n      n = k(y()),\n      a = y(),\n      r = (e => {\n        const t = new Uint8Array(e);\n        return (e => {\n          const t = {\n            \"+\": \"-\",\n            \"/\": \"_\",\n            \"=\": \"\"\n          };\n          return e.replace(/[+/=]/g, e => t[e]);\n        })(window.btoa(String.fromCharCode(...Array.from(t))));\n      })(await (async e => {\n        const t = w().subtle.digest({\n          name: \"SHA-256\"\n        }, new TextEncoder().encode(e));\n        return await t;\n      })(a)),\n      s = ((e, t, i, o, n, a, r, s) => Object.assign(Object.assign(Object.assign({\n        client_id: e.clientId\n      }, e.authorizationParams), i), {\n        scope: j(t, i.scope),\n        response_type: \"code\",\n        response_mode: s || \"query\",\n        state: o,\n        nonce: n,\n        redirect_uri: r || e.authorizationParams.redirect_uri,\n        code_challenge: a,\n        code_challenge_method: \"S256\"\n      }))(this.options, this.scope, e, o, n, r, e.redirect_uri || this.options.authorizationParams.redirect_uri || i, null == t ? void 0 : t.response_mode),\n      c = this._authorizeUrl(s);\n    return {\n      nonce: n,\n      code_verifier: a,\n      scope: s.scope,\n      audience: s.audience || \"default\",\n      redirect_uri: s.redirect_uri,\n      state: o,\n      url: c\n    };\n  }\n  async loginWithPopup(e, t) {\n    var i;\n    if (e = e || {}, !(t = t || {}).popup && (t.popup = (e => {\n      const t = window.screenX + (window.innerWidth - 400) / 2,\n        i = window.screenY + (window.innerHeight - 600) / 2;\n      return window.open(e, \"auth0:authorize:popup\", `left=${t},top=${i},width=400,height=600,resizable,scrollbars=yes,status=1`);\n    })(\"\"), !t.popup)) throw new Error(\"Unable to open a popup for loginWithPopup - window.open returned `null`\");\n    const o = await this._prepareAuthorizeUrl(e.authorizationParams || {}, {\n      response_mode: \"web_message\"\n    }, window.location.origin);\n    t.popup.location.href = o.url;\n    const n = await (e => new Promise((t, i) => {\n      let o;\n      const n = setInterval(() => {\n          e.popup && e.popup.closed && (clearInterval(n), clearTimeout(a), window.removeEventListener(\"message\", o, !1), i(new p(e.popup)));\n        }, 1e3),\n        a = setTimeout(() => {\n          clearInterval(n), i(new h(e.popup)), window.removeEventListener(\"message\", o, !1);\n        }, 1e3 * (e.timeoutInSeconds || 60));\n      o = function (r) {\n        if (r.data && \"authorization_response\" === r.data.type) {\n          if (clearTimeout(a), clearInterval(n), window.removeEventListener(\"message\", o, !1), e.popup.close(), r.data.response.error) return i(d.fromPayload(r.data.response));\n          t(r.data.response);\n        }\n      }, window.addEventListener(\"message\", o);\n    }))(Object.assign(Object.assign({}, t), {\n      timeoutInSeconds: t.timeoutInSeconds || this.options.authorizeTimeoutInSeconds || 60\n    }));\n    if (o.state !== n.state) throw new d(\"state_mismatch\", \"Invalid state\");\n    const a = (null === (i = e.authorizationParams) || void 0 === i ? void 0 : i.organization) || this.options.authorizationParams.organization;\n    await this._requestToken({\n      audience: o.audience,\n      scope: o.scope,\n      code_verifier: o.code_verifier,\n      grant_type: \"authorization_code\",\n      code: n.code,\n      redirect_uri: o.redirect_uri\n    }, {\n      nonceIn: o.nonce,\n      organization: a\n    });\n  }\n  async getUser() {\n    var e;\n    const t = await this._getIdTokenFromCache();\n    return null === (e = null == t ? void 0 : t.decodedToken) || void 0 === e ? void 0 : e.user;\n  }\n  async getIdTokenClaims() {\n    var e;\n    const t = await this._getIdTokenFromCache();\n    return null === (e = null == t ? void 0 : t.decodedToken) || void 0 === e ? void 0 : e.claims;\n  }\n  async loginWithRedirect(t = {}) {\n    var i;\n    const o = Q(t),\n      {\n        openUrl: n,\n        fragment: a,\n        appState: r\n      } = o,\n      s = e(o, [\"openUrl\", \"fragment\", \"appState\"]),\n      c = (null === (i = s.authorizationParams) || void 0 === i ? void 0 : i.organization) || this.options.authorizationParams.organization,\n      d = await this._prepareAuthorizeUrl(s.authorizationParams || {}),\n      {\n        url: u\n      } = d,\n      l = e(d, [\"url\"]);\n    this.transactionManager.create(Object.assign(Object.assign(Object.assign({}, l), {\n      appState: r\n    }), c && {\n      organization: c\n    }));\n    const h = a ? `${u}#${a}` : u;\n    n ? await n(h) : window.location.assign(h);\n  }\n  async handleRedirectCallback(e = window.location.href) {\n    const t = e.split(\"?\").slice(1);\n    if (0 === t.length) throw new Error(\"There are no query params available for parsing.\");\n    const {\n        state: i,\n        code: o,\n        error: n,\n        error_description: a\n      } = (e => {\n        e.indexOf(\"#\") > -1 && (e = e.substring(0, e.indexOf(\"#\")));\n        const t = new URLSearchParams(e);\n        return {\n          state: t.get(\"state\"),\n          code: t.get(\"code\") || void 0,\n          error: t.get(\"error\") || void 0,\n          error_description: t.get(\"error_description\") || void 0\n        };\n      })(t.join(\"\")),\n      r = this.transactionManager.get();\n    if (!r) throw new d(\"missing_transaction\", \"Invalid state\");\n    if (this.transactionManager.remove(), n) throw new u(n, a || n, i, r.appState);\n    if (!r.code_verifier || r.state && r.state !== i) throw new d(\"state_mismatch\", \"Invalid state\");\n    const s = r.organization,\n      c = r.nonce,\n      l = r.redirect_uri;\n    return await this._requestToken(Object.assign({\n      audience: r.audience,\n      scope: r.scope,\n      code_verifier: r.code_verifier,\n      grant_type: \"authorization_code\",\n      code: o\n    }, l ? {\n      redirect_uri: l\n    } : {}), {\n      nonceIn: c,\n      organization: s\n    }), {\n      appState: r.appState\n    };\n  }\n  async checkSession(e) {\n    if (!this.cookieStorage.get(this.isAuthenticatedCookieName)) {\n      if (!this.cookieStorage.get(\"auth0.is.authenticated\")) return;\n      this.cookieStorage.save(this.isAuthenticatedCookieName, !0, {\n        daysUntilExpire: this.sessionCheckExpiryDays,\n        cookieDomain: this.options.cookieDomain\n      }), this.cookieStorage.remove(\"auth0.is.authenticated\");\n    }\n    try {\n      await this.getTokenSilently(e);\n    } catch (e) {}\n  }\n  async getTokenSilently(e = {}) {\n    var t;\n    const i = Object.assign(Object.assign({\n        cacheMode: \"on\"\n      }, e), {\n        authorizationParams: Object.assign(Object.assign(Object.assign({}, this.options.authorizationParams), e.authorizationParams), {\n          scope: j(this.scope, null === (t = e.authorizationParams) || void 0 === t ? void 0 : t.scope)\n        })\n      }),\n      o = await ((e, t) => {\n        let i = A[t];\n        return i || (i = e().finally(() => {\n          delete A[t], i = null;\n        }), A[t] = i), i;\n      })(() => this._getTokenSilently(i), `${this.options.clientId}::${i.authorizationParams.audience}::${i.authorizationParams.scope}`);\n    return e.detailedResponse ? o : null == o ? void 0 : o.access_token;\n  }\n  async _getTokenSilently(t) {\n    const {\n        cacheMode: i\n      } = t,\n      o = e(t, [\"cacheMode\"]);\n    if (\"off\" !== i) {\n      const e = await this._getEntryFromCache({\n        scope: o.authorizationParams.scope,\n        audience: o.authorizationParams.audience || \"default\",\n        clientId: this.options.clientId\n      });\n      if (e) return e;\n    }\n    if (\"cache-only\" !== i) {\n      if (!(await (async (e, t = 3) => {\n        for (let i = 0; i < t; i++) if (await e()) return !0;\n        return !1;\n      })(() => ee.acquireLock(\"auth0.lock.getTokenSilently\", 5e3), 10))) throw new l();\n      try {\n        if (window.addEventListener(\"pagehide\", this._releaseLockOnPageHide), \"off\" !== i) {\n          const e = await this._getEntryFromCache({\n            scope: o.authorizationParams.scope,\n            audience: o.authorizationParams.audience || \"default\",\n            clientId: this.options.clientId\n          });\n          if (e) return e;\n        }\n        const e = this.options.useRefreshTokens ? await this._getTokenUsingRefreshToken(o) : await this._getTokenFromIFrame(o),\n          {\n            id_token: t,\n            access_token: n,\n            oauthTokenScope: a,\n            expires_in: r\n          } = e;\n        return Object.assign(Object.assign({\n          id_token: t,\n          access_token: n\n        }, a ? {\n          scope: a\n        } : null), {\n          expires_in: r\n        });\n      } finally {\n        await ee.releaseLock(\"auth0.lock.getTokenSilently\"), window.removeEventListener(\"pagehide\", this._releaseLockOnPageHide);\n      }\n    }\n  }\n  async getTokenWithPopup(e = {}, t = {}) {\n    var i;\n    const o = Object.assign(Object.assign({}, e), {\n      authorizationParams: Object.assign(Object.assign(Object.assign({}, this.options.authorizationParams), e.authorizationParams), {\n        scope: j(this.scope, null === (i = e.authorizationParams) || void 0 === i ? void 0 : i.scope)\n      })\n    });\n    t = Object.assign(Object.assign({}, r), t), await this.loginWithPopup(o, t);\n    return (await this.cacheManager.get(new C({\n      scope: o.authorizationParams.scope,\n      audience: o.authorizationParams.audience || \"default\",\n      clientId: this.options.clientId\n    }))).access_token;\n  }\n  async isAuthenticated() {\n    return !!(await this.getUser());\n  }\n  _buildLogoutUrl(t) {\n    null !== t.clientId ? t.clientId = t.clientId || this.options.clientId : delete t.clientId;\n    const i = t.logoutParams || {},\n      {\n        federated: o\n      } = i,\n      n = e(i, [\"federated\"]),\n      a = o ? \"&federated\" : \"\";\n    return this._url(`/v2/logout?${v(Object.assign({\n      clientId: t.clientId\n    }, n))}`) + a;\n  }\n  async logout(t = {}) {\n    const i = Q(t),\n      {\n        openUrl: o\n      } = i,\n      n = e(i, [\"openUrl\"]);\n    null === t.clientId ? await this.cacheManager.clear() : await this.cacheManager.clear(t.clientId || this.options.clientId), this.cookieStorage.remove(this.orgHintCookieName, {\n      cookieDomain: this.options.cookieDomain\n    }), this.cookieStorage.remove(this.isAuthenticatedCookieName, {\n      cookieDomain: this.options.cookieDomain\n    }), this.userCache.remove(\"@@user@@\");\n    const a = this._buildLogoutUrl(n);\n    o ? await o(a) : !1 !== o && window.location.assign(a);\n  }\n  async _getTokenFromIFrame(e) {\n    const t = Object.assign(Object.assign({}, e.authorizationParams), {\n        prompt: \"none\"\n      }),\n      i = this.cookieStorage.get(this.orgHintCookieName);\n    i && !t.organization && (t.organization = i);\n    const {\n      url: o,\n      state: n,\n      nonce: a,\n      code_verifier: r,\n      redirect_uri: s,\n      scope: c,\n      audience: u\n    } = await this._prepareAuthorizeUrl(t, {\n      response_mode: \"web_message\"\n    }, window.location.origin);\n    try {\n      if (window.crossOriginIsolated) throw new d(\"login_required\", \"The application is running in a Cross-Origin Isolated context, silently retrieving a token without refresh token is not possible.\");\n      const i = e.timeoutInSeconds || this.options.authorizeTimeoutInSeconds,\n        h = await ((e, t, i = 60) => new Promise((o, n) => {\n          const a = window.document.createElement(\"iframe\");\n          a.setAttribute(\"width\", \"0\"), a.setAttribute(\"height\", \"0\"), a.style.display = \"none\";\n          const r = () => {\n            window.document.body.contains(a) && (window.document.body.removeChild(a), window.removeEventListener(\"message\", s, !1));\n          };\n          let s;\n          const c = setTimeout(() => {\n            n(new l()), r();\n          }, 1e3 * i);\n          s = function (e) {\n            if (e.origin != t) return;\n            if (!e.data || \"authorization_response\" !== e.data.type) return;\n            const i = e.source;\n            i && i.close(), e.data.response.error ? n(d.fromPayload(e.data.response)) : o(e.data.response), clearTimeout(c), window.removeEventListener(\"message\", s, !1), setTimeout(r, 2e3);\n          }, window.addEventListener(\"message\", s, !1), window.document.body.appendChild(a), a.setAttribute(\"src\", e);\n        }))(o, this.domainUrl, i);\n      if (n !== h.state) throw new d(\"state_mismatch\", \"Invalid state\");\n      const p = await this._requestToken(Object.assign(Object.assign({}, e.authorizationParams), {\n        code_verifier: r,\n        code: h.code,\n        grant_type: \"authorization_code\",\n        redirect_uri: s,\n        timeout: e.authorizationParams.timeout || this.httpTimeoutMs\n      }), {\n        nonceIn: a,\n        organization: t.organization\n      });\n      return Object.assign(Object.assign({}, p), {\n        scope: c,\n        oauthTokenScope: p.scope,\n        audience: u\n      });\n    } catch (e) {\n      throw \"login_required\" === e.error && this.logout({\n        openUrl: !1\n      }), e;\n    }\n  }\n  async _getTokenUsingRefreshToken(e) {\n    const t = await this.cacheManager.get(new C({\n      scope: e.authorizationParams.scope,\n      audience: e.authorizationParams.audience || \"default\",\n      clientId: this.options.clientId\n    }));\n    if (!(t && t.refresh_token || this.worker)) {\n      if (this.options.useRefreshTokensFallback) return await this._getTokenFromIFrame(e);\n      throw new f(e.authorizationParams.audience || \"default\", e.authorizationParams.scope);\n    }\n    const i = e.authorizationParams.redirect_uri || this.options.authorizationParams.redirect_uri || window.location.origin,\n      o = \"number\" == typeof e.timeoutInSeconds ? 1e3 * e.timeoutInSeconds : null;\n    try {\n      const n = await this._requestToken(Object.assign(Object.assign(Object.assign({}, e.authorizationParams), {\n        grant_type: \"refresh_token\",\n        refresh_token: t && t.refresh_token,\n        redirect_uri: i\n      }), o && {\n        timeout: o\n      }));\n      return Object.assign(Object.assign({}, n), {\n        scope: e.authorizationParams.scope,\n        oauthTokenScope: n.scope,\n        audience: e.authorizationParams.audience || \"default\"\n      });\n    } catch (t) {\n      if ((t.message.indexOf(\"Missing Refresh Token\") > -1 || t.message && t.message.indexOf(\"invalid refresh token\") > -1) && this.options.useRefreshTokensFallback) return await this._getTokenFromIFrame(e);\n      throw t;\n    }\n  }\n  async _saveEntryInCache(t) {\n    const {\n        id_token: i,\n        decodedToken: o\n      } = t,\n      n = e(t, [\"id_token\", \"decodedToken\"]);\n    this.userCache.set(\"@@user@@\", {\n      id_token: i,\n      decodedToken: o\n    }), await this.cacheManager.setIdToken(this.options.clientId, t.id_token, t.decodedToken), await this.cacheManager.set(n);\n  }\n  async _getIdTokenFromCache() {\n    const e = this.options.authorizationParams.audience || \"default\",\n      t = await this.cacheManager.getIdToken(new C({\n        clientId: this.options.clientId,\n        audience: e,\n        scope: this.scope\n      })),\n      i = this.userCache.get(\"@@user@@\");\n    return t && t.id_token === (null == i ? void 0 : i.id_token) ? i : (this.userCache.set(\"@@user@@\", t), t);\n  }\n  async _getEntryFromCache({\n    scope: e,\n    audience: t,\n    clientId: i\n  }) {\n    const o = await this.cacheManager.get(new C({\n      scope: e,\n      audience: t,\n      clientId: i\n    }), 60);\n    if (o && o.access_token) {\n      const {\n          access_token: e,\n          oauthTokenScope: t,\n          expires_in: i\n        } = o,\n        n = await this._getIdTokenFromCache();\n      return n && Object.assign(Object.assign({\n        id_token: n.id_token,\n        access_token: e\n      }, t ? {\n        scope: t\n      } : null), {\n        expires_in: i\n      });\n    }\n  }\n  async _requestToken(e, t) {\n    const {\n        nonceIn: i,\n        organization: o\n      } = t || {},\n      n = await T(Object.assign({\n        baseUrl: this.domainUrl,\n        client_id: this.options.clientId,\n        auth0Client: this.options.auth0Client,\n        useFormData: this.options.useFormData,\n        timeout: this.httpTimeoutMs\n      }, e), this.worker),\n      a = await this._verifyIdToken(n.id_token, i, o);\n    return await this._saveEntryInCache(Object.assign(Object.assign(Object.assign(Object.assign({}, n), {\n      decodedToken: a,\n      scope: e.scope,\n      audience: e.audience || \"default\"\n    }), n.scope ? {\n      oauthTokenScope: n.scope\n    } : null), {\n      client_id: this.options.clientId\n    })), this.cookieStorage.save(this.isAuthenticatedCookieName, !0, {\n      daysUntilExpire: this.sessionCheckExpiryDays,\n      cookieDomain: this.options.cookieDomain\n    }), this._processOrgHint(o || a.claims.org_id), Object.assign(Object.assign({}, n), {\n      decodedToken: a\n    });\n  }\n}\nclass ie {}\n\n/**\r\n * The initial auth state.\r\n */\nvar initialAuthState = {\n  isAuthenticated: false,\n  isLoading: true\n};\n\n/**\r\n * @ignore\r\n */\nvar stub = function () {\n  throw new Error('You forgot to wrap your component in <Auth0Provider>.');\n};\n/**\r\n * @ignore\r\n */\nvar initialContext = __assign(__assign({}, initialAuthState), {\n  buildAuthorizeUrl: stub,\n  buildLogoutUrl: stub,\n  getAccessTokenSilently: stub,\n  getAccessTokenWithPopup: stub,\n  getIdTokenClaims: stub,\n  loginWithRedirect: stub,\n  loginWithPopup: stub,\n  logout: stub,\n  handleRedirectCallback: stub\n});\n/**\r\n * The Auth0 Context\r\n */\nvar Auth0Context = createContext(initialContext);\n\n/**\r\n * An OAuth2 error will come from the authorization server and will have at least an `error` property which will\r\n * be the error code. And possibly an `error_description` property\r\n *\r\n * See: https://openid.net/specs/openid-connect-core-1_0.html#rfc.section.3.1.2.6\r\n */\nvar OAuthError = /** @class */function (_super) {\n  __extends(OAuthError, _super);\n  function OAuthError(error, error_description) {\n    var _this = _super.call(this, error_description || error) || this;\n    _this.error = error;\n    _this.error_description = error_description;\n    // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    Object.setPrototypeOf(_this, OAuthError.prototype);\n    return _this;\n  }\n  return OAuthError;\n}(Error);\nvar CODE_RE = /[?&]code=[^&]+/;\nvar STATE_RE = /[?&]state=[^&]+/;\nvar ERROR_RE = /[?&]error=[^&]+/;\nvar hasAuthParams = function (searchParams) {\n  if (searchParams === void 0) {\n    searchParams = window.location.search;\n  }\n  return (CODE_RE.test(searchParams) || ERROR_RE.test(searchParams)) && STATE_RE.test(searchParams);\n};\nvar normalizeErrorFn = function (fallbackMessage) {\n  return function (error) {\n    if (error instanceof Error) {\n      return error;\n    }\n    // try to check errors of the following form: {error: string; error_description?: string}\n    if (error !== null && typeof error === 'object' && 'error' in error && typeof error.error === 'string') {\n      if ('error_description' in error && typeof error.error_description === 'string') {\n        return new OAuthError(error.error, error.error_description);\n      }\n      return new OAuthError(error.error);\n    }\n    return new Error(fallbackMessage);\n  };\n};\nvar loginError = normalizeErrorFn('Login failed');\nvar tokenError = normalizeErrorFn('Get access token failed');\n/**\r\n * @ignore\r\n * Helper function to map the v1 `redirectUri` option to the v2 `authorizationParams.redirect_uri`\r\n * and log a warning.\r\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nvar deprecateRedirectUri = function (options) {\n  var _a;\n  if (options === null || options === void 0 ? void 0 : options.redirectUri) {\n    console.warn('Using `redirectUri` has been deprecated, please use `authorizationParams.redirect_uri` instead as `redirectUri` will be no longer supported in a future version');\n    options.authorizationParams = options.authorizationParams || {};\n    options.authorizationParams.redirect_uri = options.redirectUri;\n    delete options.redirectUri;\n  }\n  if ((_a = options === null || options === void 0 ? void 0 : options.authorizationParams) === null || _a === void 0 ? void 0 : _a.redirectUri) {\n    console.warn('Using `authorizationParams.redirectUri` has been deprecated, please use `authorizationParams.redirect_uri` instead as `authorizationParams.redirectUri` will be removed in a future version');\n    options.authorizationParams.redirect_uri = options.authorizationParams.redirectUri;\n    delete options.authorizationParams.redirectUri;\n  }\n};\n\n/**\r\n * Handles how that state changes in the `useAuth0` hook.\r\n */\nvar reducer = function (state, action) {\n  switch (action.type) {\n    case 'LOGIN_POPUP_STARTED':\n      return __assign(__assign({}, state), {\n        isLoading: true\n      });\n    case 'LOGIN_POPUP_COMPLETE':\n    case 'INITIALISED':\n      return __assign(__assign({}, state), {\n        isAuthenticated: !!action.user,\n        user: action.user,\n        isLoading: false,\n        error: undefined\n      });\n    case 'HANDLE_REDIRECT_COMPLETE':\n    case 'GET_ACCESS_TOKEN_COMPLETE':\n      if (state.user === action.user) {\n        return state;\n      }\n      return __assign(__assign({}, state), {\n        isAuthenticated: !!action.user,\n        user: action.user\n      });\n    case 'LOGOUT':\n      return __assign(__assign({}, state), {\n        isAuthenticated: false,\n        user: undefined\n      });\n    case 'ERROR':\n      return __assign(__assign({}, state), {\n        isLoading: false,\n        error: action.error\n      });\n  }\n};\n\n/**\r\n * @ignore\r\n */\nvar toAuth0ClientOptions = function (opts) {\n  deprecateRedirectUri(opts);\n  return __assign(__assign({}, opts), {\n    auth0Client: {\n      name: 'auth0-react',\n      version: '2.2.4'\n    }\n  });\n};\n/**\r\n * @ignore\r\n */\nvar defaultOnRedirectCallback = function (appState) {\n  window.history.replaceState({}, document.title, (appState === null || appState === void 0 ? void 0 : appState.returnTo) || window.location.pathname);\n};\n/**\r\n * ```jsx\r\n * <Auth0Provider\r\n *   domain={domain}\r\n *   clientId={clientId}\r\n *   authorizationParams={{ redirect_uri: window.location.origin }}}>\r\n *   <MyApp />\r\n * </Auth0Provider>\r\n * ```\r\n *\r\n * Provides the Auth0Context to its child components.\r\n */\nvar Auth0Provider = function (opts) {\n  var children = opts.children,\n    skipRedirectCallback = opts.skipRedirectCallback,\n    _a = opts.onRedirectCallback,\n    onRedirectCallback = _a === void 0 ? defaultOnRedirectCallback : _a,\n    _b = opts.context,\n    context = _b === void 0 ? Auth0Context : _b,\n    clientOpts = __rest(opts, [\"children\", \"skipRedirectCallback\", \"onRedirectCallback\", \"context\"]);\n  var client = useState(function () {\n    return new te(toAuth0ClientOptions(clientOpts));\n  })[0];\n  var _c = useReducer(reducer, initialAuthState),\n    state = _c[0],\n    dispatch = _c[1];\n  var didInitialise = useRef(false);\n  useEffect(function () {\n    if (didInitialise.current) {\n      return;\n    }\n    didInitialise.current = true;\n    (function () {\n      return __awaiter(void 0, void 0, void 0, function () {\n        var user, appState, error_1;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              _a.trys.push([0, 7,, 8]);\n              user = void 0;\n              if (!(hasAuthParams() && !skipRedirectCallback)) return [3 /*break*/, 3];\n              return [4 /*yield*/, client.handleRedirectCallback()];\n            case 1:\n              appState = _a.sent().appState;\n              return [4 /*yield*/, client.getUser()];\n            case 2:\n              user = _a.sent();\n              onRedirectCallback(appState, user);\n              return [3 /*break*/, 6];\n            case 3:\n              return [4 /*yield*/, client.checkSession()];\n            case 4:\n              _a.sent();\n              return [4 /*yield*/, client.getUser()];\n            case 5:\n              user = _a.sent();\n              _a.label = 6;\n            case 6:\n              dispatch({\n                type: 'INITIALISED',\n                user: user\n              });\n              return [3 /*break*/, 8];\n            case 7:\n              error_1 = _a.sent();\n              dispatch({\n                type: 'ERROR',\n                error: loginError(error_1)\n              });\n              return [3 /*break*/, 8];\n            case 8:\n              return [2 /*return*/];\n          }\n        });\n      });\n    })();\n  }, [client, onRedirectCallback, skipRedirectCallback]);\n  var loginWithRedirect = useCallback(function (opts) {\n    deprecateRedirectUri(opts);\n    return client.loginWithRedirect(opts);\n  }, [client]);\n  var loginWithPopup = useCallback(function (options, config) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var error_2, user;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            dispatch({\n              type: 'LOGIN_POPUP_STARTED'\n            });\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n            return [4 /*yield*/, client.loginWithPopup(options, config)];\n          case 2:\n            _a.sent();\n            return [3 /*break*/, 4];\n          case 3:\n            error_2 = _a.sent();\n            dispatch({\n              type: 'ERROR',\n              error: loginError(error_2)\n            });\n            return [2 /*return*/];\n          case 4:\n            return [4 /*yield*/, client.getUser()];\n          case 5:\n            user = _a.sent();\n            dispatch({\n              type: 'LOGIN_POPUP_COMPLETE',\n              user: user\n            });\n            return [2 /*return*/];\n        }\n      });\n    });\n  }, [client]);\n  var logout = useCallback(function (opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    return __awaiter(void 0, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, client.logout(opts)];\n          case 1:\n            _a.sent();\n            if (opts.openUrl || opts.openUrl === false) {\n              dispatch({\n                type: 'LOGOUT'\n              });\n            }\n            return [2 /*return*/];\n        }\n      });\n    });\n  }, [client]);\n  var getAccessTokenSilently = useCallback(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  function (opts) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var token, error_3, _a;\n      var _b;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            _c.trys.push([0, 2, 3, 5]);\n            return [4 /*yield*/, client.getTokenSilently(opts)];\n          case 1:\n            token = _c.sent();\n            return [3 /*break*/, 5];\n          case 2:\n            error_3 = _c.sent();\n            throw tokenError(error_3);\n          case 3:\n            _a = dispatch;\n            _b = {\n              type: 'GET_ACCESS_TOKEN_COMPLETE'\n            };\n            return [4 /*yield*/, client.getUser()];\n          case 4:\n            _a.apply(void 0, [(_b.user = _c.sent(), _b)]);\n            return [7 /*endfinally*/];\n          case 5:\n            return [2 /*return*/, token];\n        }\n      });\n    });\n  }, [client]);\n  var getAccessTokenWithPopup = useCallback(function (opts, config) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var token, error_4, _a;\n      var _b;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            _c.trys.push([0, 2, 3, 5]);\n            return [4 /*yield*/, client.getTokenWithPopup(opts, config)];\n          case 1:\n            token = _c.sent();\n            return [3 /*break*/, 5];\n          case 2:\n            error_4 = _c.sent();\n            throw tokenError(error_4);\n          case 3:\n            _a = dispatch;\n            _b = {\n              type: 'GET_ACCESS_TOKEN_COMPLETE'\n            };\n            return [4 /*yield*/, client.getUser()];\n          case 4:\n            _a.apply(void 0, [(_b.user = _c.sent(), _b)]);\n            return [7 /*endfinally*/];\n          case 5:\n            return [2 /*return*/, token];\n        }\n      });\n    });\n  }, [client]);\n  var getIdTokenClaims = useCallback(function () {\n    return client.getIdTokenClaims();\n  }, [client]);\n  var handleRedirectCallback = useCallback(function (url) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var error_5, _a;\n      var _b;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            _c.trys.push([0, 2, 3, 5]);\n            return [4 /*yield*/, client.handleRedirectCallback(url)];\n          case 1:\n            return [2 /*return*/, _c.sent()];\n          case 2:\n            error_5 = _c.sent();\n            throw tokenError(error_5);\n          case 3:\n            _a = dispatch;\n            _b = {\n              type: 'HANDLE_REDIRECT_COMPLETE'\n            };\n            return [4 /*yield*/, client.getUser()];\n          case 4:\n            _a.apply(void 0, [(_b.user = _c.sent(), _b)]);\n            return [7 /*endfinally*/];\n          case 5:\n            return [2 /*return*/];\n        }\n      });\n    });\n  }, [client]);\n  var contextValue = useMemo(function () {\n    return __assign(__assign({}, state), {\n      getAccessTokenSilently: getAccessTokenSilently,\n      getAccessTokenWithPopup: getAccessTokenWithPopup,\n      getIdTokenClaims: getIdTokenClaims,\n      loginWithRedirect: loginWithRedirect,\n      loginWithPopup: loginWithPopup,\n      logout: logout,\n      handleRedirectCallback: handleRedirectCallback\n    });\n  }, [state, getAccessTokenSilently, getAccessTokenWithPopup, getIdTokenClaims, loginWithRedirect, loginWithPopup, logout, handleRedirectCallback]);\n  return React.createElement(context.Provider, {\n    value: contextValue\n  }, children);\n};\n\n/**\r\n * ```js\r\n * const {\r\n *   // Auth state:\r\n *   error,\r\n *   isAuthenticated,\r\n *   isLoading,\r\n *   user,\r\n *   // Auth methods:\r\n *   getAccessTokenSilently,\r\n *   getAccessTokenWithPopup,\r\n *   getIdTokenClaims,\r\n *   loginWithRedirect,\r\n *   loginWithPopup,\r\n *   logout,\r\n * } = useAuth0<TUser>();\r\n * ```\r\n *\r\n * Use the `useAuth0` hook in your components to access the auth state and methods.\r\n *\r\n * TUser is an optional type param to provide a type to the `user` field.\r\n */\nvar useAuth0 = function (context) {\n  if (context === void 0) {\n    context = Auth0Context;\n  }\n  return useContext(context);\n};\n\n/**\r\n * ```jsx\r\n * class MyComponent extends Component {\r\n *   render() {\r\n *     // Access the auth context from the `auth0` prop\r\n *     const { user } = this.props.auth0;\r\n *     return <div>Hello {user.name}!</div>\r\n *   }\r\n * }\r\n * // Wrap your class component in withAuth0\r\n * export default withAuth0(MyComponent);\r\n * ```\r\n *\r\n * Wrap your class components in this Higher Order Component to give them access to the Auth0Context.\r\n *\r\n * Providing a context as the second argument allows you to configure the Auth0Provider the Auth0Context\r\n * should come from f you have multiple within your application.\r\n */\nvar withAuth0 = function (Component, context) {\n  if (context === void 0) {\n    context = Auth0Context;\n  }\n  return function WithAuth(props) {\n    return React.createElement(context.Consumer, null, function (auth) {\n      return React.createElement(Component, __assign({}, props, {\n        auth0: auth\n      }));\n    });\n  };\n};\n\n/**\r\n * @ignore\r\n */\nvar defaultOnRedirecting = function () {\n  return React.createElement(React.Fragment, null);\n};\n/**\r\n* @ignore\r\n*/\nvar defaultOnBeforeAuthentication = function () {\n  return __awaiter(void 0, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n      return [2 /*return*/];\n    });\n  });\n};\n/**\r\n * @ignore\r\n */\nvar defaultReturnTo = function () {\n  return \"\".concat(window.location.pathname).concat(window.location.search);\n};\n/**\r\n * ```js\r\n * const MyProtectedComponent = withAuthenticationRequired(MyComponent);\r\n * ```\r\n *\r\n * When you wrap your components in this Higher Order Component and an anonymous user visits your component\r\n * they will be redirected to the login page; after login they will be returned to the page they were redirected from.\r\n */\nvar withAuthenticationRequired = function (Component, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return function WithAuthenticationRequired(props) {\n    var _this = this;\n    var _a = options.returnTo,\n      returnTo = _a === void 0 ? defaultReturnTo : _a,\n      _b = options.onRedirecting,\n      onRedirecting = _b === void 0 ? defaultOnRedirecting : _b,\n      _c = options.onBeforeAuthentication,\n      onBeforeAuthentication = _c === void 0 ? defaultOnBeforeAuthentication : _c,\n      loginOptions = options.loginOptions,\n      _d = options.context,\n      context = _d === void 0 ? Auth0Context : _d;\n    var _e = useAuth0(context),\n      isAuthenticated = _e.isAuthenticated,\n      isLoading = _e.isLoading,\n      loginWithRedirect = _e.loginWithRedirect;\n    useEffect(function () {\n      if (isLoading || isAuthenticated) {\n        return;\n      }\n      var opts = __assign(__assign({}, loginOptions), {\n        appState: __assign(__assign({}, loginOptions && loginOptions.appState), {\n          returnTo: typeof returnTo === 'function' ? returnTo() : returnTo\n        })\n      });\n      (function () {\n        return __awaiter(_this, void 0, void 0, function () {\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                return [4 /*yield*/, onBeforeAuthentication()];\n              case 1:\n                _a.sent();\n                return [4 /*yield*/, loginWithRedirect(opts)];\n              case 2:\n                _a.sent();\n                return [2 /*return*/];\n            }\n          });\n        });\n      })();\n    }, [isLoading, isAuthenticated, loginWithRedirect, onBeforeAuthentication, loginOptions, returnTo]);\n    return isAuthenticated ? React.createElement(Component, __assign({}, props)) : onRedirecting();\n  };\n};\nexport { Auth0Context, Auth0Provider, u as AuthenticationError, d as GenericError, P as InMemoryCache, z as LocalStorageCache, m as MfaRequiredError, f as MissingRefreshTokenError, OAuthError, p as PopupCancelledError, h as PopupTimeoutError, l as TimeoutError, ie as User, initialContext, useAuth0, withAuth0, withAuthenticationRequired };","map":null,"metadata":{},"sourceType":"module"}